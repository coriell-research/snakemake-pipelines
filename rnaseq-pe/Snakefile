import pandas as pd


configfile: "config.yaml"

SAMPLES = pd.read_csv("samples.csv", sep=",", header=0)
SAMPLES_LIST = SAMPLES["sample_name"].tolist()

WORK_DIR = "../data"
FASTP_OUT = f"{WORK_DIR}/01_fastp"
STAR_OUT = f"{WORK_DIR}/02_star"
SALMON_OUT = f"{WORK_DIR}/03_salmon"
RSEQC_OUT = f"{WORK_DIR}/04_rseqc"
MULTIQC_OUT = f"{WORK_DIR}/05_multiqc"


rule all:
    input:
        f"{MULTIQC_OUT}/multiqc_report.html"


rule fastp:
    input:
        r1 = lambda w: SAMPLES.loc[SAMPLES["sample_name"] == w.sample, "read1"].item(),
        r2 = lambda w: SAMPLES.loc[SAMPLES["sample_name"] == w.sample, "read2"].item()
    output:
        r1_out = temp(f"{FASTP_OUT}/{{sample}}.trimmed.1.fq.gz"),
        r2_out = temp(f"{FASTP_OUT}/{{sample}}.trimmed.2.fq.gz"),
        html = f"{FASTP_OUT}/{{sample}}.fastp.html",
        json = f"{FASTP_OUT}/{{sample}}.fastp.json"
    log:
        f"{FASTP_OUT}/{{sample}}_fastp.log"
    params:
        extra = config["fastp"]["extra_params"]
    shell:
        "fastp -i {input.r1} -I {input.r2} -o {output.r1_out} -O {output.r2_out} "
        "{params.extra} --html {output.html} --json {output.json} &> {log}"


rule star_align:
    input:
        r1 = f"{FASTP_OUT}/{{sample}}.trimmed.1.fq.gz",
        r2 = f"{FASTP_OUT}/{{sample}}.trimmed.2.fq.gz"
    output:
        bam = f"{STAR_OUT}/{{sample}}.Aligned.sortedByCoord.out.bam",
        log_final = f"{STAR_OUT}/{{sample}}.Log.final.out"
    log:
        f"{STAR_OUT}/{{sample}}/star.log"
    threads: config["star"]["threads"]
    params:
        star_index = config["star"]["index_dir"],
        out_prefix = f"{STAR_OUT}/{{sample}}.",
        read_cmd = config["star"]["readFilesCommand"],
        two_pass = config["star"]["twopassMode"],
        multi_mappers = config["star"]["outFilterMultimapNmax"],
        multi_anchor = config["star"]["winAnchorMultimapNmax"],
        sj_overhang_min = config["star"]["alignSJoverhangMin"],
        sjdb_overhang_min = config["star"]["alignSJDBoverhangMin"],
        mismatches = config["star"]["outFilterMismatchNmax"],
        mismatch_ratio = config["star"]["outFilterMismatchNoverLmax"],
        intron_min = config["star"]["alignIntronMin"],
        intron_max = config["star"]["alignIntronMax"],
        max_gap = config["star"]["alignMatesGapMax"],
        min_score_ratio = config["star"]["outFilterScoreMinOverLread"],
        min_match_ratio = config["star"]["outFilterMatchNminOverLread"],
        n_junctions = config["star"]["limitSjdbInsertNsj"],
        strand_field = config["star"]["outSAMstrandField"],
        quant_mode = config["star"]["quantMode"],
        out_type = config["star"]["outSAMtype"],
        sam_attributes = config["star"]["outSAMattributes"]
    shell:
      """
      STAR --genomeDir {params.star_index} \
        --readFilesIn {input.r1} {input.r2} \
        --outFileNamePrefix {params.out_prefix} \
        --runThreadN {threads} \
        --readFilesCommand {params.read_cmd} \
        --twopassMode {params.two_pass} \
        --outFilterMultimapNmax {params.multi_mappers} \
        --winAnchorMultimapNmax {params.multi_anchor} \
        --alignSJoverhangMin {params.sj_overhang_min} \
        --alignSJDBoverhangMin {params.sjdb_overhang_min} \
        --outFilterMismatchNmax {params.mismatches} \
        --outFilterMismatchNoverLmax {params.mismatch_ratio} \
        --alignIntronMin {params.intron_min} \
        --alignIntronMax {params.intron_max} \
        --alignMatesGapMax {params.max_gap} \
        --outFilterScoreMinOverLread {params.min_score_ratio} \
        --outFilterMatchNminOverLread {params.min_match_ratio} \
        --limitSjdbInsertNsj {params.n_junctions} \
        --outSAMstrandField {params.strand_field} \
        --quantMode {params.quant_mode} \
        --outSAMtype {params.out_type} \
        --outSAMattributes {params.sam_attributes} &> {log}
       """


rule index_bam:
    input:
        f"{STAR_OUT}/{{sample}}.Aligned.sortedByCoord.out.bam"
    output:
        f"{STAR_OUT}/{{sample}}.Aligned.sortedByCoord.out.bam.bai"
    shell:
        "samtools index {input}"


rule salmon_quant:
    input:
        r1 = f"{FASTP_OUT}/{{sample}}.trimmed.1.fq.gz",
        r2 = f"{FASTP_OUT}/{{sample}}.trimmed.2.fq.gz", 
    output:
        quant_sf = f"{SALMON_OUT}/{{sample}}/quant.sf",
        lib_format_counts = f"{SALMON_OUT}/{{sample}}/lib_format_counts.json"
    log:
        f"{SALMON_OUT}/{{sample}}/salmon.log"
    params:
        salmon_index = config["salmon"]["index_dir"],
        extra = config["salmon"]["extra_params"],
        threads = config["salmon"]["threads"],
        lib_type = config["salmon"]["lib_type"],
        gibbs = config["salmon"]["gibbs"],
        output_dir = f"{SALMON_OUT}/{{sample}}"
    shell:
      """
        salmon quant \
          --index {params.salmon_index} \
          --libType {params.lib_type} \
          --mates1 {input.r1} --mates2 {input.r2} \
          --threads {params.threads} \
          --numGibbsSamples {params.gibbs} \
          --output {params.output_dir} {params.extra} &> {log}
      """


rule read_distribution:
    input:
        bam = f"{STAR_OUT}/{{sample}}.Aligned.sortedByCoord.out.bam",
        bai = f"{STAR_OUT}/{{sample}}.Aligned.sortedByCoord.out.bam.bai"
    output:
        report = f"{RSEQC_OUT}/{{sample}}.read_distribution.txt"
    log:
        f"{RSEQC_OUT}/{{sample}}.read_distribution.log"
    params:
        gene_model = config["rseqc"]["gene_model"]
    conda:
        "rseqc"
    shell:
        """read_distribution.py -i {input.bam} -r {params.gene_model} > {output}"""


# tin.py writes to working dir 
rule tin:
    input:
        bam = f"{STAR_OUT}/{{sample}}.Aligned.sortedByCoord.out.bam",
        bai = f"{STAR_OUT}/{{sample}}.Aligned.sortedByCoord.out.bam.bai"
    output:
        out_tin = f"{RSEQC_OUT}/{{sample}}.Aligned.sortedByCoord.out.tin.xls",
        out_summary = f"{RSEQC_OUT}/{{sample}}.Aligned.sortedByCoord.out.summary.txt"
    log:
        f"{RSEQC_OUT}/{{sample}}.tin.log"
    params:
        gene_model = config["rseqc"]["gene_model"],
        min_cov = config["rseqc"]["min_cov"],
        sample_size = config["rseqc"]["sample_size"]
    conda:
        "rseqc"
    shell:
        """
        tin.py -i {input.bam} \
          -r {params.gene_model} \
          -c {params.min_cov} \
          -n {params.sample_size} && \
          mv {wildcards.sample}.Aligned.sortedByCoord.out.summary.txt {output.out_summary} && \
          mv {wildcards.sample}.Aligned.sortedByCoord.out.tin.xls {output.out_tin}
        """


rule multiqc_report:
    input:
        expand(f"{FASTP_OUT}/{{sample}}.fastp.html", sample=SAMPLES_LIST),
        expand(f"{FASTP_OUT}/{{sample}}.fastp.json", sample=SAMPLES_LIST),
        expand(f"{STAR_OUT}/{{sample}}.Log.final.out", sample=SAMPLES_LIST),
        expand(f"{SALMON_OUT}/{{sample}}/quant.sf", sample=SAMPLES_LIST),
        expand(f"{RSEQC_OUT}/{{sample}}.read_distribution.txt", sample=SAMPLES_LIST),
        expand(f"{RSEQC_OUT}/{{sample}}.Aligned.sortedByCoord.out.tin.xls", sample=SAMPLES_LIST)
    output:
        html_report = f"{MULTIQC_OUT}/multiqc_report.html",
        data_dir = directory(f"{MULTIQC_OUT}/multiqc_data")
    log:
        f"{MULTIQC_OUT}/multiqc.log"
    params:
        search_dir = WORK_DIR,
        output_dir = MULTIQC_OUT
    shell:
        "multiqc {params.search_dir} -o {params.output_dir} &> {log}"